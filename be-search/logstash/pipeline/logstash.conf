input {
  jdbc {
    jdbc_driver_library => "/usr/share/logstash/mysql-connector-java.jar"
    jdbc_driver_class => "com.mysql.cj.jdbc.Driver"
    jdbc_connection_string => "jdbc:mysql://host.docker.internal:3306/chart_db"
    jdbc_user => "root"
    jdbc_password => "1234"
    schedule => "*/30 * * * * *"
    statement => "
      SELECT
        p.patient_id,
        p.name,
        p.phone,
        JSON_ARRAYAGG(
          JSON_OBJECT(
            'patientDetailId',pd.patient_detail_id,
            'hospitalId',       pd.hospital_id,
            'vipType',          pd.vip_type,
            'classificationCd', pd.classification_cd,
            'firstVisitDate',   DATE_FORMAT(pd.first_visit_date, '%Y-%m-%d')
          )
          ORDER BY pd.hospital_id
        ) AS patients_json,
        GREATEST(
          p.update_time,
          (
            SELECT MAX(pd2.update_time)
            FROM patient_detail pd2
            WHERE pd2.patient_id = p.patient_id
          )
        ) AS updated_at
      FROM patient p
      LEFT JOIN patient_detail pd ON pd.patient_id = p.patient_id
      WHERE p.update_time > :sql_last_value
        OR EXISTS (
          SELECT 1
          FROM patient_detail pdx
          WHERE pdx.patient_id = p.patient_id AND pdx.update_time > :sql_last_value)
      GROUP BY p.patient_id
      ORDER BY updated_at;
    "
    use_column_value => true
    tracking_column => "updated_at"
    tracking_column_type => "timestamp"
    last_run_metadata_path => "/usr/share/logstash/.logstash_jdbc_last_run"
    clean_run => false
  }

  # 물리 삭제된 고객 문서 삭제
  jdbc {
    jdbc_driver_library => "/usr/share/logstash/mysql-connector-java.jar"
    jdbc_driver_class => "com.mysql.cj.jdbc.Driver"
    jdbc_connection_string => "jdbc:mysql://host.docker.internal:3306/chart_db"
    jdbc_user => "root"
    jdbc_password => "1234"
    schedule => "*/30 * * * * *"
    statement => "
      SELECT
        d.patient_id,
        d.deleted_time
      FROM patient_delete d
      WHERE d.deleted_time > :sql_last_value
      ORDER BY d.deleted_time
    "
    use_column_value => true
    tracking_column => "deleted_time"
    tracking_column_type => "timestamp"
    last_run_metadata_path => "/usr/share/logstash/.logstash_jdbc_last_run_patient_delete"
    clean_run => false
    add_field => { "[@metadata][event_type]" => "patient_delete" }
    tags => ["patient_delete"]
  }

  # 환자 상세(중첩) 항목 삭제 → 배열에서 해당 patientDetailId만 제거
  jdbc {
    jdbc_driver_library => "/usr/share/logstash/mysql-connector-java.jar"
    jdbc_driver_class => "com.mysql.cj.jdbc.Driver"
    jdbc_connection_string => "jdbc:mysql://host.docker.internal:3306/chart_db"
    jdbc_user => "root"
    jdbc_password => "1234"
    schedule => "*/30 * * * * *"
    statement => "
      SELECT
        dd.patient_id,
        dd.patient_detail_id,
        dd.hospital_id,
        dd.deleted_time
      FROM patient_detail_delete dd
      WHERE dd.deleted_time > :sql_last_value
      ORDER BY dd.deleted_time
    "
    use_column_value => true
    tracking_column => "deleted_time"
    tracking_column_type => "timestamp"
    last_run_metadata_path => "/usr/share/logstash/.logstash_jdbc_last_run_patient_detail_delete"
    clean_run => false
    add_field => { "[@metadata][event_type]" => "patient_detail_delete" }
    tags => ["patient_detail_delete"]
  }
}

filter {
  # 삭제 이벤트는 본문 변환 스킵
  if "patient_delete" in [tags] or "patient_detail_delete" in [tags] {
  } else {
    # patients_json(JSON 문자열) -> patients(배열[객체]) 파싱
    json {
      source => "patients_json"
      target => "patients"
      skip_on_invalid_json => true
    }

    # patients에 포함된 null 요소 제거 및 타입 보정
    ruby {
      code => "
        pts = event.get('patients')
        if pts.is_a?(Array)
          pts = pts.compact
          pts.each do |h|
            next unless h.is_a?(Hash)
            hid = h['hospitalId']
            h['hospitalId'] = hid.to_i if !hid.nil?
          end
          event.set('patients', pts)
        else
          event.set('patients', [])
        end
      "
    }

    # phone_rev 생성(끝자리 검색 최적화용)
    ruby {
      code => "
        ph = event.get('phone')
        event.set('phone_rev', ph.to_s.reverse) if ph
      "
    }

    # 불필요 필드 정리
    mutate {
      remove_field => ["patients_json", "@version", "@timestamp", "host"]
    }
  }

  # patient_detail_delete용: 스크립트 파라미터 구성(문자열→숫자 안전 변환)
  if "patient_detail_delete" in [tags] {
    ruby {
      code => "
        pid = event.get('patient_detail_id')
        if pid
          begin
            event.set('[@metadata][pd_id]', pid.to_i)
          rescue
            event.set('[@metadata][pd_id]', nil)
          end
        end
      "
    }
  }
}

output {
  if "patient_delete" in [tags] {
    elasticsearch {
      hosts => ["http://elasticsearch:9200"]
      index => "patient-index"              # 또는 쓰기 alias
      document_id => "%{patient_id}"
      action => "delete"
    }
  } else if "patient_detail_delete" in [tags] {
    elasticsearch {
      hosts => ["http://elasticsearch:9200"]
      index => "patient-index"        # 사용하는 인덱스/alias로 맞추세요
      document_id => "%{patient_id}"
      action => "update"
      scripted_upsert => false
      script_lang => "painless"
      script_type => "inline"
      # 큰따옴표를 그대로 쓰기 위해 script 문자열은 작은따옴표로 감싼다(역슬래시 제거)
      script => '
        String pidStr = "%{[@metadata][pd_id]}";
        if (pidStr == null || pidStr.length() == 0) { return; }
        long pidVal;
        try { pidVal = Long.parseLong(pidStr); } catch (Exception e) { return; }

        if (ctx._source.containsKey("patients") && ctx._source.patients != null) {
          def newArr = new ArrayList();
          for (p in ctx._source.patients) {
            if (p == null) continue;
            def pdid = p.containsKey("patientDetailId") ? p.patientDetailId : null;
            if (pdid != null) {
              long pdidVal;
              if (pdid instanceof Number) {
                pdidVal = ((Number) pdid).longValue();
              } else {
                try { pdidVal = Long.parseLong(pdid.toString()); } catch (Exception e2) { pdidVal = -1L; }
              }
              if (pdidVal == pidVal) { continue; } // 해당 항목 제거
            }
            newArr.add(p);
          }
          ctx._source.patients = newArr;
        }
      '
      retry_on_conflict => 3
    }
  } else {
    elasticsearch {
      hosts => ["http://elasticsearch:9200"]
      index => "patient-index"              # 또는 쓰기 alias(e.g., patient_write)
      document_id => "%{patient_id}"
      action => "update"
      doc_as_upsert => true
    }
    stdout { codec => json_lines }
  }
}
